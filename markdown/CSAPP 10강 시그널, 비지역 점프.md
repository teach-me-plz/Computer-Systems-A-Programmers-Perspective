# 챕터8 예외적인 제어흐름
## 지난 시간에 다룬 내용
- Exception (예외)
	- 하드웨어 + OS 소프트웨어 조합
	- Interrupt, Trap, Fault, Abort
- 프로세스
	- 두 가지 추상화
		1. 논리적 제어 흐름 (context switching으로 구현)
		2. 사적 주소 공간 (가상 메모리로 구현)
- 프로세스 제어
	- fork(), exit(), wait(), waitpid()
- 프로그램 실행
	- execve()
	- fork + execve로 간단한 쉘을 만들 수 있음


쉘 예시
```c
// 의사 코드
while (true)
{
	s = read_input(stdin);  // 유저 인풋 읽기
	argv = parse_line(s);   // 문자열 -> 벡터로 변환
	bg = is_bg?(argv);      // 백그라운드 실행인지 플래그 설정
	
	pid = fork();
	if (!pid)               // 자식 프로세스는 새 프로그램 실행 후 종료
	{
		call_execve(s);
		exit(0);
	}
	if (!bg)                // 백그라운드 실행(&)이 아닌 경우 프로세스 종료 대기
		waitpid(pid, &status, 0);
	else
		print(pid);         // 백그라운드 실행인 경우 새로 생긴 프로세스의 id 출력
}
```

## 그런데 말입니다..
fork와 execve로만 만든 간단한 쉘은 문제가 쪼금 있다..

포어그라운드로 실행시에는 waitpid로 프로세스의 종료를 기다리기 때문에 자원 회수를 다 함

근데 백그라운드의 경우
- 프로세스가 종료되면 좀비 프로세스가 된다 (wait 함수 호출이 없음)
- 쉘이 꺼질 때 까지 회수되지 않음 -> 쉘은 일반적으로 끄지 않음
- 메모리 누수를 유발할 수 있음

## 여기서 필요한 것이 ECF
그럼 백그라운드 프로세스가 종료될때 알려주면 되잖아?

-> 네 그게 signal입니다~


# 시그널
## 시그널?
작은 메시지(= 신호)
프로세스에게 시스템 내에 어떤 종류의 이벤트가 일어났다는 것을 알려줌

소프트웨어적인 interrupt?

커널 -> 프로세스로 보냄

리눅스에서는 1번부터 30번까지 있음

전달되는건 id값 밖에 없음

## 시그널 보내기(배달)

커널은 목적지 프로세스의 컨텍스트 내에 있는 일부 상태를 갱신해서 시그널을 목적지 프로세스로 보낸다.
-> 말이 어렵긴 한데 풀어서 보면 안어려움

시그널을 보낸다 == 도착지 프로세스에 있는 **pending 비트 벡터 (시그널 마스크)** 조작

나중에 해당 프로세스가 실행될 때 '아 이런 시그널이 왔었구나' 하고 확인할 수 있게 하는거

### 커널이 언제 시그널을 보내나
1. 커널이 0으로 나누기 / 자식 프로세스의 종료 같은 시스템 이벤트 감지
2. 어떤 프로세스가 커널에 명시적으로 시그널을 목적지 프로세스에 보낼것을 요구하기 위해 kill 함수를 호출

프로세스는 시그널을 자기 자신에게 보낼 수 있음!

## 시그널 받기
목적지 프로세스는 배달된 신호에 대해서 커널이 어떤 방식으로 반응해야 할 때 목적지 프로세스는 시그널을 받는다(읽는다).
-> 번역이 좆같아도 참아요 우리

적당히 의역하면 '목적지 프로세스가 **실행**될 때 (블록되지 않은) 시그널을 받는다' 요런 뜻

즉 컨텍스트 스위칭이 끝나는 시점에서 처리가 된다



블록한 시그널은 블록을 풀 때까지는 수신되지 않음!

### 나머지 시그널은 어떻게 반응(react) 하는지
- 무시: 아무것도 안함
- 종료: 프로세스 종료 (시그널에 따라 코어 덤프)
- 획득(Catch): 사용자 수준 함수인 signal handler 실행
	- 지난 시간에 다룬 인터럽트와 유사 (제어 흐름에서 잠시 벗어나 핸들러 실행)

## 펜딩 시그널

a -> b
b 프로세스가 시작될 때 처리해야하는 시그널 모음

보내졌지만 아직 받지 않은 시그널은 펜딩 시그널이라고 부른다.
시간상으로 어떤 시점에서, 특정 타입에 대해 최대 한 개의 펜딩 시그널이 존재할 수 있다.

-> 한 아파트(프로세스)에 30개의 우편함이 있고, 커널이 시그널을 보내면 우편함에 들어간다.
근데 우편함에는 편지가 하나밖에 안들어가는.. 그런 우편함임
몇개가 왔는지 모른다. 있다 없다만 알 수 있음

앞에걸 버릴수도 or 뒤에걸 버릴수도?
ㅈ댔노 ㅋㅋ

시그널은 큐가 아님 주의 -> FIFO아님, 같은 시그널 2개 있을 수 없음

## 블록된 시그널
어떤 시그널이 블록될 때 배달(send)은 될 수 있지만, 블록을 풀 때까지는 수신되지 않는다.

### 어떻게 그게 됨?
비트벡터 방식

```
숫자 대신 O / X 로 표현

signal number    | 1 | 2 | 3 | 4 | 5
pending bits     | O | X | O | O | X
allowed bits     | O | O | O | X | O     <- 4번 시그널 블록됨

result           | O | X | O | X | X     <- 4번 시그널은 수신되지 않음  
```

시그널이 배달올때 -> pending의 k번째 비트 켜기
시그널을 받을 때   -> pending의 k번째 비트 끄기

블록 비트벡터는 sigprocmask 함수로 비트 세팅 가능

시그널 마스크랑 같은 말임

## 시그널을 보내보자

### kill 프로그램으로 시그널 보내기
/bin/kill 프로그램으로 특정 프로세스(pid) / 프로세스 그룹(pgid)에 시그널을 보낼 수 있음

```sh
/bin/kill -9 24818 # 24818 프로세스에 SIGKILL 전송

/bin/kill -9 -24817 # 24817 프로세스 그룹에 있는 모든 프로세스에 전송
```


### 키보드 입력으로 시그널 보내기
ctrl-c 입력으로 SIGINT 시그널을 포그라운드 프로세스 그룹에 전송
ctrl-z도 마찬가지 (SIGSTP)

- SIGINT - default action은 각 프로세스를 종료하는 것
- SIGSTP - default action은 각 프로세스를 정지(suspend) 하는것

![[스크린샷 2025-11-15 오후 7.37.23.png]]
top을 실행 후 sigstp 한 뒤 kill로 프로세스 종료

### kill 함수 사용
`int kill(pid_t pid, int sig);`

pid에 sig를 보내는 시스템콜 함수

pid > 0  --> 해당 pid를 가진 프로세스에 시그널 전송
pid == 0 --> kill 함수를 호출한 pgid에 있는 모든 프로세스에 전송
pid == -1 --> 시스템 프로세스와 시그널을 보내는 프로세스를 제외한 모든 프로세스에 전송
pid < -1 --> 입력값의 절댓값을 pgid로 가지는 프로세스에 전송

-1을 사용하는 예시
```c
#include "signal.h"

int main(void)
{
    kill(-1, 9);
    return (0);
}
```

한번 실행해봤는데 진짜 다꺼짐 ㅋㅋㅋㅋ
심지어 화면도..

### 잠깐 이전 과제를 살펴보면..
```c
/* 세마포어는 무시 가능!! 12장에서 다시 만나요 */
void	serial_killer(t_info *info, pid_t *pid)
{
	int	i;

	i = 0;
	sem_wait(info->print);
	while (i < info->number_of_philo)
	{
		kill(pid[i], SIGINT); // pid 배열을 순회하면서 시그널 전송
		i++;
	}
	sem_post(info->print);
}
```

어떤 부분을 개선할 수 있을까?
1. 아까 다룬 pgid를 사용하면 그룹 안에 있는 모든 프로세스에 한번에 시그널을 보낼 수 있다. 
2. 수거(reaping)을 하지 않고 있다...^^;;
   (실제로는 바깥 함수에서 waitpid 하고 있어요..!)

개선하면 
```c
void	serial_killer(t_info *info, pid_t pgid) // 부모를 제외한 자식의 프로세스 그룹
{
	kill(-pgid, SIGINT);
	while (wait(NULL) > 0)
	    ;
}
```

이렇게 간단한 코드가 된다는 말씀~~

근디 과제 허용 함수에 setpgid()가 없고 wait() 대신 waitpid() 써야되긴함~


## 시그널이 수신되는 타이밍
시그널이 언제 처리(수신)되냐?

*커널이 예외를 처리하고 난 뒤 다시 사용자 프로세스로 돌아가려고 하는 시점*

참고로
컨텍스트 스위칭도 예외 핸들러를 통해 시작된다

컨텍스트 스위칭이 되었던, 시스템콜 함수 호출이 되었던 커널 모드에서 다시 제어를 돌려주는 시점에 pnb를 계산(확인)한다.

pnb: pending nonblocked signals (걍 처리해야 하는 시그널임 대충)

`pnb = pending & ~blocked` 로 pnb를 구할 수 있다.

만약 pnb == 0이면?
그냥 원래 복귀해야 하던 instruction 지점으로 복귀하면 됨

pnb != 0이면?

작은 비트부터 확인해서 해당 시그널을 하나씩 처리함
0이 될 때 까지 반복하고 프로세스의 다음 instruction으로 복귀

3개 시그널 -> 3개 다 처리하고 복귀

## 시그널 핸들러
```c
// 원본 버전
void (*signal(int signum, void (*handler)(int)))(int);

// 책 버전
typedef void handler_t(int);
handler_t *signal(int signum, handler_t *handler);

// man 버전
typedef void (*sig_t)(int);
sig_t signal(int sig, sig_t func);
```

성공시 이전 핸들러가 리턴,
실패시 SIG_ERR가 리턴되고 errno 설정

```c
if (sinal(SIGINT, sigint_handler) == SIG_ERR)
	error_exit();
```

### 시그널 핸들러 사용법
은 넘어갈게요~ 미니톡 안했어도 미니쉘에서 써보셨죠?

## 시그널도 동시적이래
병렬 말고 동시적!!!
![[스크린샷 2025-11-16 오전 10.28.18.png]]

프로세스 A의 반복문을 실행하는 와중에 프로세스 A의 핸들러도 실행되는 모습을 볼 수 있다.

프로세스 B에서 프로세스 A로 돌아오는 시점에 핸들러가 호출됨 (아까 이야기 했던 '목적지 프로세스가 실행될 때')

![[스크린샷 2025-11-16 오전 10.30.18.png]]
핸들러와 메인 코드의 실행 순서


### 핸들러 실행 중에 또 다른 핸들러가?!
예 가능합니다

시그널 s1을 처리하는 와중에 s2시그널이 수신되면
s2처리하고 다시 s1핸들러로 돌아옴

(벌써 머리 아프다 그죠? 그치만 아직 좀 더 남았어...)


## 블록된 시그널과 안블록된 시그널
암시적인 블록
- 지금 처리하는 중인 시그널은 블록된다.
- ex> sigint 핸들러는 sigint핸들러로 interrupt 할 수 없음

명시적인 블록/언블록
- sigprocmask 함수 사용

도움 함수
- sigemptyset
- sigfillset
- sigaddset
- sigdelset

### 잠깐만 블록(언블록) 하고 싶다면
```c
sigset_t mask, prev_mask;

sigemptyset(&mask);
sigaddset(&mask, SIGINT);

sigprocmask(SIG_BLOCK, &mask, &prev_mask);
// 여기 있는 코드는 sigint로 멈추지 않는다고~
sigprocmask(SIG_BLOCK, &prev_mask, NULL);
```
이런 식으로 사용해보십쇼


## 안전한 시그널 핸들링
메인 프로그램과 핸들러는 concurrent 하면서 전역 데이터 구조를 공유한다.
-> 고장나기 딱 좋다

### 안전한 핸들러 제작 가이드라인
1. 핸들러는 최대한 심플하게 작성
   ex> 전역 플래그 세팅 후 리턴 -> 메인 컨트롤 플로우에서 플래그를 확인하고 미리 정의된 동작 실행
2. async-signal-safe 함수만 호출하기
   printf, malloc, exit 이런 함수는 안전하지 않음
3. errno 저장하고 복원하기
   핸들러가 기존 errno를 덮어쓰지 않게
4. 공유된 전역 자료구조로의 접근을 보호하라 (시그널 블록을 사용해서)
   아래 예시 코드로 설명함
5. 전역변수는 volatile로 선언 -> 무조건 메모리에서 읽어야 하는 변수다!
   컴파일러가 값을 메모리에서 읽어올 수 있도록
6. sig_atomic_t로 플래그 선언 (읽기 쓰기만 하는 변수 ex> flag * 2)
   시그널 핸들러 <-> 메인 흐름 간의 플래그 공유에서 사용

꼭 다 지킬 필요는 없는 보수적인 가이드라인

ex> printf의 모든 문장이 임의의 핸들러에 의해 절대로 중단되지 않을 것을 증명할 수 있으면 핸들러에 사용해도 됨

근데 그게 쉽나?
### 공유 전역 자료구조 보호?
```c
volatile sig_atomic_t got_sigint = 0; // sig_atomic_t로 보호

void handler(int sig) { got_sigint = 1; }

int main()
{
	while (1)
	{
	    sigset_t all, old;
	    sigfillset(&all);
	    // 다른 시그널을 블락해서 전역 자료구조 변경이 중단되지 않도록 설정
	    sigprocmask(SIG_BLOCK, &all, &old);
	
	    if (got_sigint)
	    {
	        got_sigint = 0;
	        do_safe_work();   // 전역 자료구조 안전하게 수정
	    }
	
	    sigprocmask(SIG_SETMASK, &old, NULL);
	}
}
```

리스트에 원소 추가
리스트 제일 끝에 새로운 노드 연결
새로운 노드의 넥스트를 널로 설정

뮤텍스 / 세마포어랑 비슷함
### 핸들러에서 위험한 함수 사용해보기
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void sigint_handler(int sig)
{
    printf("hello from handler!\n");
    printf("hello from handler!\n");
}

int main(void)
{
    if (signal(SIGINT, sigint_handler) == SIG_ERR)
        return (1);

    printf("filling buffer... (press Ctrl+C)\n");

    // flush하지 않고 버퍼를 계속 채움
    for (int i = 0; i < 100000000; i++)
    {
        printf("x"); // 여기서 내부 lock을 잡고 있음
        // 고의로 flush 금지
    }
    pause();
}
```

요 코드를 실행하고 SIGINT 시그널을 주면

![[스크린샷 2025-11-16 오전 10.10.08.png]]


사실 쉽게 데드락이 걸리지는 않음
저 코드도 5번 시도하면 한번 데드락이 걸리는 정도?
나머지는 정상적으로 핸들러 호출 되고 프로그램도 잘 종료됨

그런데 그게 더 문제임

이런 버그는 재현도 어렵고 디버그도 빡셈
실행이 잘 될 때는 print도 잘되니 핸들러에서 함수 호출을 한게 잘못되었다고 알아채기 어려움

그러니 보수적인 가이드라인을 제시하는듯


## Async-Signal-Safety
그래서 어떤 함수가 안전한데?

비동기-시그널-안전한 함수: 재진입 가능 함수거나, 시그널에 의해 방해받지 않는 함수

재진입 가능 함수 (12장에서 다룰 예정):
대충 전역/정적 변수를 사용하지 않는 함수라고 생각하면 될듯? 
쓰는 모든 데이터 / 변수가 스택 프레임 안에 있음


시그널에 방해받지 않는 함수: write처럼 원자적으로 실행되는 함수(분절 불가능)

[안전한 함수 목록](https://man7.org/linux/man-pages/man7/signal-safety.7.html)

대표적인 안전한 함수
- `_exit`, `write`, `wait`, `waitpid`, `sleep`, `kill` 등

대표적인 안전하지 **않은** 함수
- `printf` `sprintf`, `malloc`, `exit` 등
- 안타깝지만 출력 함수는 write만 안전하다

ft_printf를 malloc 없이 구현했다면 그것도 핸들러에서 사용 가능하긴 하다만...

그냥 libft에서 만들었던 putstr이랑 putnbr 쓰세용
## 올밥른 시그널 핸들링
익숙한 필로소퍼 과제를 다시 까볼까 했는데..
필로소퍼에서 메인 프로세스는 자식을 생성 후 특별하게 따로 하는 일이 없기 때문에
그냥 waitpid 걸어두는게 쉽고 편하고 안전함

굳이 시그널을 받아서 처리할 필요가 없다
메인 프로세스가 바쁜것도 아님
타임 크리티컬한가 ? 아니요



그냥 일반적인 예시를 보자.

![[스크린샷 2025-11-18 오전 1.43.18.png]]
![[스크린샷 2025-11-18 오전 1.45.38.png]]
자식 프로세스가 종료되면 SIGCHLD 시그널이 부모 프로세스로 전송된다.
이 핸들러는 해당 시그널을 받으면 wait를 해서 자식 프로세스를 수거함.

![[스크린샷 2025-11-18 오전 1.47.30.png]]
그런데 
1. 왜 5개의 자식 프로세스 중에 2개 밖에 수거하지 못했을까?

2가지 이유
1. 시그널은 한번에 하나만 pending 가능
2. 시그널을 처리중에는 해당 시그널은 자동으로 블록된다.

### 타임 라인
첫번째 자식이 죽음 (시그널 보냄)

메인은 시그널 받고 핸들러 호출
sigchd 비트는 0으로 초기화

핸들러에서 첫번째 자식 수거 이후 1초 대기 <- 이동안 나머지 4개 프로세스도 종료

다시 펜딩 시그널에 1 기록

핸들러 종료 후 시그널 언블록

펜딩 시그널에 1이 있으니 다시 핸들러 호출
(핸들러를 호출하는 시점에 펜딩 시그널은 0으로 초기화)


그래서 총 2번임





또 어떻게 수정하면 빠짐 없이 모두 수거할 수 있을까?

if문을 while로 바꾸자
-> 자식 프로세스가 죽었다는 시그널 != 자식 한명이 죽었다.

자식 프로세스가 죽었다는 시그널 == 자식 중에 최소 한명이 죽었다.
몇명이 죽었는지 모르니까 수거가 안될 때까지 wait를 반복

힌트: 여러번 실행해도 매번 2개만 수거된다.


수거가 안중요한 이유
메모리 쥐똥만큼만 차지함
신경 써야하는건 pid 차지하는거 정도?
심지어 부모 프로세스가 종료되면 pid 1이나 systemd가 알아서 회수함 ㅋㅋ

부모 프로세스가 일반적으로 안죽는 경우 (쉘, 서버)
이때는 그럼 경준이 말처럼 분리하시죠?
백그라운드 프로세스 등

## 시그널이 들어올 때 까지 대기하기
```c
while (!signal_flag)
	;

while (!signal_flag)
	sleep(1);
	
while (!signal_flag)
	// <- 여기서 이미 플래그는 설정되어 있음 + pending 시그널은 0으로 초기화
	pause(); // 얘의 탈출조건은 새로운 시그널 수신 (플래그 on /off 여부가 아님)
```

첫 번째 반복문 -> 잘 작동함. 낭비는 심하지만..
두 번째 반복문 -> 잘 작동하고, 낭비도 덜함. 대신 느림..
세 번째 반복문 -> 시그널이 어긋나면 무한대기

이럴때는 `sigsuspend` 라는 함수를 쓰면 됩니다

만... 이 수업에서 다루지는 않겠습니다.
요청하면 설명해드림


# 비지역 점프(Nonlocal jumps)
프로그램의 흐름을 임의의 위치로 점프할 수 있는 아주아주 강력한 메커니즘
try catch의 원시형 느낌

에러 복구나 시그널 핸들링에 유용하다.

`int setjmp(jmp_buf j)`
- 아래 나올 longjmp 호출시 돌아올 위치를 j에 저장한다. (레지스터 컨텍스트, 스택 포인터, pc 값)
- 당연히 longjmp 전에 호출되어야 함
- 저장시에는 0을 리턴하고, longjmp로 올때는 longjmp 인자 값을 리턴

`void longjmp(jmp_buf j, int i)`
- 인자 j에 저장된 위치로 점프한다
- 그러면 setjmp가 i에 넣은 값으로 리턴됨
- 당연히 setjmp 이후에 호출되어야 함


물론 동적 할당한거 직접 다 해제해줘야함ㅋㅋ
그치만 c++의 try catch 보다 훨씬 빠르심


사용 예시

```c
#include <setjmp.h>

jmp_buf env;

void f() {
    longjmp(env, 1);  // env는 main의 유효한 스택 상태
}

int main() {
    switch (setjmp(env)) {
        case 0:
            f();      // 정상 흐름
            break;
        case 1:
            break;    // longjmp 이후 흐름
    }
    return 0;
}
```

이미 종료된 함수 환경으로는 점프할 수 없음
물론 호출되지 않은 함수로 점프할 수도 없음

호출 되었지만 종료되지 않은 함수로만 점프 가능

-> try catch 구문도 마찬가지

잘못된 사용 예시
```c
#include <setjmp.h>

jmp_buf env;

void foo() {
    switch (setjmp(env)) {
        case 0:
            return;   // 여기서 env가 담고 있는 foo의 스택 프레임이 사라짐
        case 1:
            break;    // ❌ 이 case는 도달할 수 없는 UB 상황
    }
}

int main() {
    foo();
    bar();
    longjmp(env, 1);  // ❌ foo의 파괴된 스택 프레임으로 점프 → UB
    return 0;
}
```


# 수업 끝
세줄 요약
1. 시그널은 프로세스 레벨의 예외 처리를 가능하게 하며 상당히! 유용하다.
2. 물론 핸들러는 매우 신경써서 작성해야 한다 (동시성 때문)
3. 비지역 점프로 수많은 리턴, 리턴, 리턴을 건너뛸 수 있지만 마찬가지로 조심하자.