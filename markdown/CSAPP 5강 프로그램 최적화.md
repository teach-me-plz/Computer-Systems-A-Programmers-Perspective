
## 왜 최적화가 중요한가?

- ### 성능의 현실
    
    - 알고리즘의 시간 복잡도(Big-O)만큼 상수 인자(constant factor)도 중요함.
        
    - 코드 작성 방식에 따라 성능은 10배 이상 차이 날 수 있음.
        
- ### 최적화를 하기 위해서는
    
    - 프로그램이 어떻게 컴파일되고 실행되는지 이해.
        
    - 현대 프로세서와 메모리 시스템의 동작 방식 이해.
        
    - 성능 병목을 찾아 코드를 개선하는 방법 이해.
        

## 컴파일러 최적화와 그 한계

- ### 컴파일러 최적화의 역할
    
    - 레지스터 할당, 코드 순서 재배치 등 기계어 수준의 최적화 수행.
        
    - 간단한 비효율 제거.

	- (보통) 점근적인 효율성을 개선시켜 주지는 않음
		- 너가 알고리즘 잘 골라야겠지?
		- 몇 번이고 이야기 하지만 상수항도 중요하다.
        
- ### 컴파일러의 한계: "최적화 저해 요인"
    
    - 컴파일러는 프로그램의 동작을 절대 변경해서는 안 됨.
      
	- 대부분의 최적화를 위한 분석은 프로시저 단위로 실행됨
        
    - 따라서 잠재적인 위험이 있다면, 보수적으로 동작하여 최적화를 포기함.

## 유용한 최적화
- 프로세서/컴파일러에 관계없이 사용자나 컴파일러가 수행해야 하는 최적화
- ### 코드 이동 (Code Motion)
	- 계산이 수행되는 빈도 줄이기
	  
		- 항상 동일한 결과를 생성할 경우
		  
		- 특히 루프 안에서 밖으로
		  
```c
// 최적화 전
void set_row(double *a, double *b, long i, long n)
{
    long j;
    for (j = 0; j < n; j++)
        a[n*i + j] = b[j];
}

// 최적화 후
void set_row(double *a, double *b, long i, long n)
{     
	long j;
	int ni = n*i;
	for (j = 0; j < n; j++)
		a[ni+j] = b[j];
}
```

- ### Reduction in Strength
	- 비용이 많이 드는 연산을 더 간단한 연산으로 대체
	  
	- 곰셉을 시프트로 대체하는 등
	  
## 컴파일러의 최적화 저해 요소 (Optimization Blocker)
	
- ### 저해 요인 1: 프로시저 호출
    
    - **문제 상황:** 루프 조건문에서 `strlen`과 같은 함수를 반복 호출.
        
```c
`// N이 커질수록 성능이 N²에 비례하여 느려짐 
for (i = 0; i < strlen(s); i++) { ... }`
```


- **원인:** 컴파일러는 `strlen` 함수가 다른 전역 변수에 영향을 주는 등 **부수 효과(Side Effect)** 가 있을지 알 수 없음. 그래서 매번 호출하는 코드를 그대로 유지함.
	
- **해결책:** 함수의 결괏값이 변하지 않는다면, 루프 시작 전에 변수에 미리 저장. (코드 이동)
	
```c
// 성능이 N에 비례 (선형적) 
size_t len = strlen(s); 
for (i = 0; i < len; i++) { ... }
```
	
- ### 저해 요인 2: 메모리 앨리어싱 (Memory Aliasing)
    
- **문제 상황:** 서로 다른 포인터가 사실은 같은 메모리 주소를 가리키는 경우.
        
```c
// b[i]와 a[i*n+j]가 같은 메모리를 가리킬 수 있음
for (j = 0; j < n; j++)
    b[i] += a[i*n + j];
```
        
- **원인:** 컴파일러는 `b[i]`에 값을 더하는 것이 `a` 배열의 다른 값에 영향을 줄 가능성을 배제할 수 없음. 그래서 최적화를 주저함.
	
- **해결책:** 계산 결과를 **지역 변수(local variable)**에 누적한 뒤, 루프가 끝나고 마지막에 한 번만 메모리에 저장.
	
```c
double val = 0;
for (j = 0; j < n; j++)
    val += a[i*n + j];
b[i] = val; // 메모리 접근 최소화
```


```c
// 극단적인 예시
void twiddle1(long *xp, long *yp)
{
	*xp += *yp;
	*xp += *yp; -> *xp = 4
}

void twiddle2(long *xp, long *yp)
{
	*xp += 2 * *yp; // 만약 xp, yp가 같다면?
}
```
## 명령어 수준 병렬성 활용
- ### 현대 CPU의 특징: 슈퍼스칼라 & 파이프라이닝
    
    - **슈퍼스칼라 (Superscalar):** 한 번에 여러 개의 명령어를 처리.
        
    - **파이프라이닝 (Pipelining):** 하나의 명령어를 여러 단계로 나누어 동시에 다른 명령어의 다른 단계를 처리.
        
    - CPU 내 여러 **기능 유닛(Functional Unit)** 이 병렬로 동작함.
        
- ### 성능 저하의 주범: 데이터 종속성 (Data Dependency)
    
    - 다음 계산이 이전 계산의 결과에 의존하는 순차적인 코드.
        
```c
// t의 이전 값이 다음 t를 계산하는 데 바로 사용됨 (순차적 종속성)
for (i = 0; i < length; i++)
    t = t * d[i];
```
	
- 이 경우, CPU의 병렬 처리 능력을 전혀 활용하지 못하고, 연산의 **지연 시간(Latency)** 이 전체 성능을 결정함.
        
- ### 해결책 1: 루프 언롤링 (Loop Unrolling) + 재결합
    
    - 루프를 풀어 여러 연산을 한 번에 수행하도록 변경.
        
    - **핵심:** 계산 순서를 바꿔 데이터 종속성을 제거.
        
```c
// Before: (x * d[i]) * d[i+1] -> 순차적
// After:  x * (d[i] * d[i+1]) -> d[i]*d[i+1]을 미리 계산 가능
for (i = 0; i < limit; i+=2) {
    x = x * (d[i] * d[i+1]);
}
```
        
- ### 해결책 2: 다중 누적 변수 활용 (2x2 Unrolling)
    
    - 가장 효과적인 방법 중 하나.
        
    - 독립적인 계산 흐름을 여러 개 만들어 CPU가 완벽히 병렬 처리하도록 유도.
        
```c
// x0와 x1은 서로에게 영향을 주지 않는 독립적인 계산
data_t x0 = 1;
data_t x1 = 1;
for (i = 0; i < limit; i+=2) {
   x0 = x0 * d[i];
   x1 = x1 * d[i+1];
}
*dest = x0 * x1;
```
        
- **효과:** 데이터 종속성이 사라져 CPU의 **처리량 한계(Throughput Bound)**까지 성능을 끌어올릴 수 있음. 성능이 2배 이상 향상됨.
        

## 또 다른 현실: 분기 예측

- ### 조건 분기문의 문제
    
    - CPU는 파이프라인을 꽉 채우기 위해 다음 실행할 명령어를 미리 가져와야 함.
        
    - 하지만 `if`문이나 루프의 `jmp` 명령어는 결과가 나오기 전까지 어디로 분기할지 알 수 없음.
        
- ### CPU의 해결책: 분기 예측 (Branch Prediction)
    
    - "아마 이쪽으로 분기할 것이다"라고 추측하고, 해당 경로의 명령어를 미리 실행 파이프라인에 올림.
        
    - **예측 성공 시:** 성능 저하 없음.
        
    - **예측 실패 시:** 파이프라인에 미리 올린 모든 작업을 폐기하고, 올바른 경로의 명령어로 다시 채워야 함. 이 과정에서 **엄청난 성능 저하 (수십 사이클 손실)** 가 발생.
        
- ### 프로그래머의 역할
    
    - 규칙적이고 예측 가능한 패턴의 분기문은 빠름 (예: 대부분 반복되는 루프).
        
    - 데이터에 따라 결과가 불규칙하게 바뀌는 분기문은 성능 저하의 원인이 될 수 있음.
        

## 정리 

- **컴파일러 친화적 코드 작성**
    
    - 루프 내 불필요한 함수 호출을 피하라.
        
    - 메모리 앨리어싱을 피하기 위해 지역 변수를 적극 활용하라.
        
- **하드웨어 특성 활용**
    
    - 데이터 종속성을 끊어 명령어 수준 병렬성을 극대화하라. (루프 언롤링, 다중 누적 변수)
        
- **성능 저하 요인 인지**
    
    - 예측하기 어려운 분기문은 비싸다는 것을 기억하라.
        
- **결론: 시스템을 이해하는 만큼 프로그램은 빨라진다.**