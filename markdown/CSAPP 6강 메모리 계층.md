
# 왜 메모리 계층이 필요한가?
Memory Hierarchy


<img src=https://cstaleem.com/wp-content/uploads/2020/08/Memory-Hierarchy-in-COA.png>
## CPU-메모리 성능 격차 문제

- CPU 성능은 매우 빠르게 향상됨
    
- 메모리(DRAM) 성능 향상은 상대적으로 느림
    
- 시간이 지날수록 CPU와 메모리 간 속도 격차가 더 벌어짐
    
- 이 문제를 해결하는 핵심이 **메모리 계층**임
    

## 성능 비교 (접근 시간 기준)

- CPU 레지스터: 즉시 접근 가능
    
- SRAM: 1-3 ns
    
- DRAM: 50-100 ns

- 디스크: 수 ms (수백만 배 느림)
    

# 저장 장치의 종류와 특징

## RAM (Random Access Memory)

## SRAM vs DRAM 비교

- SRAM - Static Random Access Memory
- DRAM - Dynamic Random Access Memory

| 특징          | SRAM      | DRAM     |
| ----------- | --------- | -------- |
| **속도**      | 매우 빠름     | 상대적으로 느림 |
| **비용**      | 비쌈 (100배) | 저렴       |
| **트랜지스터 수** | 6개/비트     | 1개/비트    |
| **전력 소모**   | 적음        | 많음       |
| **재충전 필요**  | 불필요       | 필요       |
| **주 용도**    | 캐시 메모리    | 주 메모리    |

## 핵심 특징

- SRAM은 빠르지만 비쌈 → 캐시용으로 사용
    
- DRAM은 느리지만 저렴 → 메인 메모리용으로 사용
    
- 둘 다 휘발성 메모리임 (전원 꺼지면 데이터 사라짐)
    

## 비휘발성 메모리

## 종류와 특징

- **ROM**: 제조 시 프로그램됨, 변경 불가 -> BIOS
    
- **PROM**: 한 번만 프로그램 가능 -> OTP
    
- **EPROM**: 자외선으로 전체 삭제 가능
    
- **EEPROM**: 전기적으로 삭제 가능
    
- **Flash Memory**: 블록 단위 삭제 가능, SSD에 사용
    

## 주요 용도

- 펌웨어 저장 (BIOS 등)
    
- SSD (Solid State Drive)
    
- 디스크 캐시
    

## HDD (Hard Disk Drive)

- 물리적 디스크를 회전시키는 방식
    
- 매우 느림 (수 ms 접근 시간)
    
- 현재는 대부분 SSD로 대체됨
    
- 탐색 시간 + 회전 지연 시간이 성능을 좌우함


## SSD (Solid State Drive)
- 반도체 기반의 저장장치

- 움직이는 부품이 없음 → 물리적 지연이 없음

- 접근 시간이 매우 빠름 (수십~수백 μs 수준)

- 내구성, 속도, 소비 전력 측면에서 HDD보다 우수함

- 비용은 GB당 HDD보다 비싸지만, 가격은 지속적으로 하락 중

- 플래시 메모리를 사용하며, 셀 종류(SLC, MLC, TLC, QLC)에 따라 성능과 수명이 달라짐

- 데이터는 페이지 단위로 읽고 쓰지만, 페이지에 쓰기 전에 해당 블록 전체가 먼저 지워져야 함
# 지역성의 원리 (Principle of Locality)

## 지역성이란?

- 프로그램은 특정 데이터와 그 주변에 반복적으로 접근하는 경향이 있음
    
- 메모리 계층이 효과적으로 동작하는 핵심 원리임
    

## 시간적 지역성 (Temporal Locality)

- **정의**: 최근에 참조된 항목은 가까운 미래에 다시 참조될 가능성이 높음
    
- **예시**: 반복문의 변수들
    

```c
long sum = 0;
for (int i = 0; i < N; i++) {
    sum += a[i];  // sum과 i는 계속 재참조됨
}
```

## 공간적 지역성 (Spatial Locality)

- **정의**: 한 항목이 참조되면 그 근처 주소의 항목들도 곧 참조될 가능성이 높음
    
- **예시**: 배열의 순차적 접근
    

```c
// 좋은 예 (행 우선 접근)
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        sum += a[i][j];  // 메모리 상에서 연속된 위치 접근
    }
}

// 나쁜 예 (열 우선 접근)
for (int j = 0; j < N; j++) {
    for (int i = 0; i < N; i++) {
        sum += a[i][j];  // 메모리 상에서 떨어진 위치 접근
    }
}

1 2 3
4 5 6
7 8 9

1 2 3 4 5 6 7 8 9
```

## 지역성의 중요성

- 지역성이 높은 프로그램이 더 빠름
    
- 캐시 히트율이 높아짐
    
- 전체 시스템 성능 향상
    

# 메모리 계층과 캐싱

## 메모리 계층 구조
```
CPU 레지스터     ← 가장 빠름, 가장 작음, 가장 비쌈
    ↓
L1 캐시 (SRAM)
    ↓
L2 캐시 (SRAM)
    ↓
L3 캐시 (SRAM)
    ↓
주 메모리 (DRAM)
    ↓
로컬 저장소 (SSD)
    ↓
원격 저장소      ← 가장 느림, 가장 큼, 가장 저렴
```
## 캐시의 기본 원리

- **캐시**: 더 빠르고 작은 메모리가 더 느리고 큰 메모리의 데이터 일부를 임시 저장
    
- **각 레벨은 바로 아래 레벨의 캐시 역할**을 함
    
- 지역성 때문에 대부분의 접근이 상위 레벨에서 처리됨
    

## 캐시 동작 과정

1. CPU가 데이터 요청
    
2. L1 캐시에서 먼저 검색
    
3. **캐시 히트**: 데이터가 있으면 바로 사용 (매우 빠름)
    
4. **캐시 미스**: 데이터가 없으면 하위 레벨에서 검색
    
5. 찾은 데이터를 상위 캐시에 복사 (다음 사용을 위해)
    

# 캐시 미스의 종류

## 콜드 미스 (Cold Miss)

- 캐시가 비어있어서 발생
    
- 프로그램 시작 시 불가피함
    
- **필수적인 미스**임
    

## 용량 미스 (Capacity Miss)

- 캐시 용량이 부족해서 발생
    
- 작업 집합이 캐시보다 클 때 발생
    
- **캐시 크기를 늘리면 해결**됨
    

## 충돌 미스 (Conflict Miss)

- 캐시 공간은 있지만 여러 데이터가 같은 위치에 매핑되어 발생
    
- **캐시 연관성을 높이면 해결**됨
    

# 실제 성능 향상 효과

## 왜 메모리 계층이 효과적인가?

- **지역성** 때문에 대부분의 메모리 접근이 캐시에서 처리됨
    
- **캐시 히트율**이 90% 이상인 경우가 많음
    
- 결과적으로 **빠른 메모리의 속도**와 **큰 메모리의 용량**을 동시에 얻음
    

## 성능 계산 예시

- L1 캐시 히트율: 95% (1ns 접근 시간)
    
- L2 캐시 히트율: 4% (10ns 접근 시간)
    
- DRAM 접근: 1% (100ns 접근 시간)
    
- **평균 접근 시간**: 0.95×1 + 0.04×10 + 0.01×100 = 2.35ns
    

## 프로그래밍 시 고려사항

- **배열은 행 우선으로 접근**하는 것이 유리함
  -> 가까이 있는 데이터부터 쓰게 하자
    
- **반복 사용되는 데이터는 변수에 저장**하는 것이 유리함 + 함수 결과는 미리 받아와서 저자하자
    
- **메모리 접근 패턴을 예측 가능**하게 만드는 것이 유리함
    

## 정리

## 핵심 개념

- **CPU-메모리 격차**는 계속 벌어지고 있음
    
- **참조의 지역성**은 프로그램의 기본 특성임
    
- **메모리 계층**은 이 격차를 해결하는 핵심 방법임
    
- **캐싱**은 지역성을 활용하여 성능을 향상시킴


2025년 지금은?

메모리가 빨라져서 좀 괜찮지 않나?
했는데

cpu가 더빨라졌어
심지어 멀티로 동시에 작동하고

Non Uniformed Memory Architecture

그럼 오늘 수업은 여기까지구요
다들 고생하셨습니다



## 실무 적용

- 효율적인 프로그래밍을 위해서는 **메모리 접근 패턴을 고려**해야 함
    
- **지역성을 높이는 코드**가 더 빠른 프로그램을 만듦
    
- **캐시 친화적인 알고리즘**을 선택하는 것이 중요함