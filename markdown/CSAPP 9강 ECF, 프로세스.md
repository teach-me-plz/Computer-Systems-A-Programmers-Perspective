
## 예외적 제어 흐름, 프로세스, 그리고 프로세스 제어


---

<div style="page-break-after: always;"></div>

# 제어 흐름의 기본과 한계

## 들어가며: 왜 제어 흐름을 이해해야 하는가?

### 🤔 CPU는 어떻게 작동할까?

- CPU는 끊임없이 명령어를 실행한다
    
- 이 명령어들의 **연속적인 실행 순서** = 제어 흐름(Control Flow)
    
- 하지만 단순히 순서대로만 실행한다면...
    
    - 복잡한 운영 체제 구현 불가능
        
    - 외부 상황 변화에 대응 불가
        

🤷‍♂️ **디스크에서 데이터가 도착하거나, 사용자가 Ctrl-C를 누르면?**

👉 **답은 '예외적 제어 흐름'에 있다!**

---

<div style="page-break-after: always;"></div>

## 정상적인 제어 흐름

### 📋 CPU의 기본 동작

- 시스템 켜짐 → 꺼질 때까지
    
- 메모리의 명령어들을 **순차적으로** 읽어와 하나씩 실행
    

### 🔀 전통적인 제어 흐름 변경 방법

1. **Jumps / Branches** (점프와 분기)
    
    - `if`, `for`, `switch` 문
        
    - 특정 조건에 따라 다른 부분으로 이동
        
2. **Call / Return** (호출과 반환)
    
    - 함수 호출 → 실행 완료 → 원래 위치로 복귀
        

### 🔑 공통점

- **프로그램 내부의 상태**에 따라 제어 흐름 결정
    
- 변수 값, 계산 결과 등
    

---

<div style="page-break-after: always;"></div>

## 시스템 상태 변화와 제어 흐름의 도전 과제

### ⚠ 전통적인 방법의 한계

예를 들어 이런 상황들은?

- 🌐 네트워크로 새 데이터 패킷 도착
    
- ➗ 프로그램이 0으로 나누기 같은 오류 발생
    
- ⌨️ 사용자가 Ctrl-C로 프로그램 강제 종료 시도
    
- ⏰ 시스템 관리용 타이머 만료
    

### 🚫 문제점

- 프로그램 코드의 **직접적인 결과가 아님**
    
- **예측 불가능한 시점**에 발생
    
- 전통적인 제어 흐름으로는 대처 어려움
    

### 💡 해결책

**예외적 제어 흐름(Exceptional Control Flow, ECF)** 필요!

- 시스템의 갑작스러운 상태 변화에 대응
    
- 제어 흐름을 비정상적으로 변경하는 모든 방법
    

---

<div style="page-break-after: always;"></div>

# 예외적 제어 흐름(ECF) 개요

## 들어가며: 지능적인 메커니즘, ECF

### 🧠 단순한 오류 처리를 넘어서

ECF는 현대 운영 체제를 가능하게 하는 **근본적인 메커니즘**

- 하드웨어/소프트웨어 이벤트 감지 및 관리
    
- 여러 프로그램 동시 실행(동시성)
    
- 한정된 시스템 자원의 효율적 분배
    

### 🚀 ECF 없다면?

- 멀티태스킹 ❌
    
- 메모리 보호 ❌
    
- 심지어 단순한 I/O도 ❌
    

👉 **ECF = 현대 컴퓨터 시스템의 지능적 작동 기반 기술!**

---

<div style="page-break-after: always;"></div>

## ECF의 계층적 구조

### 저수준 메커니즘 (Low-level)

- **예외 (Exceptions)**
    
    - 하드웨어 + 운영 체제(OS) 소프트웨어 조합
        

### 고수준 메커니즘 (High-level)

- **프로세스 문맥 교환 (Process Context Switch)**
    
    - OS 소프트웨어 + 하드웨어 타이머
        
- **신호 (Signals)**
    
    - OS 소프트웨어
        
- **비지역적 점프 (Nonlocal Jumps)**
    
    - C 런타임 라이브러리: `setjmp()`, `longjmp()`
        

## 🎯 본 강의의 초점

- 가장 근본적인 **'예외'**
    
- 이를 기반으로 한 **'프로세스'** 및 **'프로세스 제어'**
    

---

<div style="page-break-after: always;"></div>

# 깊이 보기: 예외(Exceptions)의 작동 원리

## 들어가며: 예외란 무엇인가?

### 🔍 예외가 뭔가요

**예외(Exception)** = 프로그램 오류 ❌

**예외(Exception)** = 프로세서 상태 변화(이벤트)에 대응하여 OS 커널이 시스템 통제권을 확보하는 **가장 기본적인 방법** ✅

### 🛠 운영 체제의 핵심 기능들

- 하드웨어 이벤트 처리
    
- 사용자 프로그램 요청(시스템 콜) 수행
    
- **모두 예외 메커니즘 위에서 동작!**
    

---

<div style="page-break-after: always;"></div>

## 예외의 정의와 처리 과정

### 📋 예외의 정의

프로세서 상태의 변화로 표현되는 **이벤트(event)** 에 대응하여 OS 커널로 **제어권을 이전(transfer of control)** 하는 것

### 🔄 예외 처리 흐름

1. **이벤트 발생**: 사용자 코드 실행 중 (`I_current`) 예외 유발
    
2. **커널로 제어권 이전**: CPU가 실행 중단 → 미리 정해진 커널 코드(예외 핸들러)로 이동
    
3. **예외 처리**: 커널의 예외 핸들러가 원인 파악 → 적절한 조치
    
4. **처리 후 복귀 또는 중단**: 결과에 따라 3가지 중 하나 선택
    
    - **현재 명령어(`I_current`)로 복귀**: 폴트 처리 완료 후
        
    - **다음 명령어(`I_next`)로 복귀**: 트랩/인터럽트 처리 완료 후
        
    - **프로그램 중단(Abort)**: 복구 불가능한 치명적 오류
        

---

<div style="page-break-after: always;"></div>

## 예외 테이블: 이벤트와 핸들러의 연결고리

### 🤔 어떻게 수많은 이벤트를 구분할까?

**예외 테이블(Exception Table)** 또는 **인터럽트 벡터(Interrupt Vector)**

### 🔧 작동 방식

1. **시스템 부팅 시**: OS가 메모리에 예외 테이블 생성
    
2. **각 이벤트**: 고유한 **예외 번호(k)** 부여 -> 운영체제 abi에서 정의
    
3. **예외 발생 시**: CPU가 예외 번호(k)로 테이블의 k번째 항목 찾기
    
4. **핸들러 실행**: 해당 항목에 저장된 핸들러 주소로 점프

** 보충 필요 **

    

```
예외 번호 | 핸들러 주소
    0     | 0x8000100  // 나누기 오류
    1     | 0x8000200  // 디버그 예외
    2     | 0x8000300  // NMI 인터럽트
   ...    |    ...
```
---

<div style="page-break-after: always;"></div>

## 예외의 종류와 특성 분석

### 📊 발생 원인에 따른 분류

| 구분                      | 발생 원인                 | 주요 특징             | 대표 사례                                    | 처리 후 복귀 위치                         |
| ----------------------- | --------------------- | ----------------- | ---------------------------------------- | ---------------------------------- |
| **비동기식 예외** (Interrupt) | 프로세서 외부 이벤트           | 인터럽트 핀을 통해 발생     | - 타이머 인터럽트  <br>- 키보드 입력<br>- 네트워크 패킷 도착 | 다음 명령어 (`I_next`)                  |
| **동기식 예외** (Trap)       | 명령어 실행 (의도적)          | 시스템 콜, <br>디버깅 목적 | - read, fork 등 시스템 콜  <br>- 브레이크포인트      | 다음 명령어 (`I_next`)                  |
| **동기식 예외** (Fault)      | 명령어 실행 (비의도적, 복구 가능)  | 잠재적으로 복구 가능       | - 페이지 폴트  <br>- 보호 폴트  <br>- 부동 소수점 예외   | 현재 명령어(`I_current`) 재실행 또는 프로그램 중단 |
| **동기식 예외** (Abort)      | 명령어 실행 (비의도적, 복구 불가능) | 복구 불가능한 치명적 오류    | - 잘못된 명령어 실행  <br>- 하드웨어 패리티 오류          | 현재 프로그램 중단<br>블루스크린(윈도우)           |

---

<div style="page-break-after: always;"></div>

## 구체적 예시로 본 예외 처리

### 🎯 트랩 예시 (시스템 콜)

사용자 프로그램이 `open()` 함수로 파일을 열려고 할 때:

1. `open()` 함수 내부에서 `syscall` 명령어 실행
    
2. **의도적으로** 트랩 발생 → 제어권이 커널로 이전
    
3. 커널이 요청받은 파일을 열고 결과 반환
    
4. 제어권을 `syscall` 명령어 **다음 위치**(`I_next`)로 복귀
    
5. 프로그램 실행 재개
    

```c
int fd = open("myfile.txt", O_RDONLY); // syscall 내부 호출 
printf("File descriptor: %d\n", fd);   // 여기서 실행 재개
```
---

<div style="page-break-after: always;"></div>

## 🛠 폴트 예시 1 (페이지 폴트 - 복구 가능)

`movl` 명령어로 메모리 접근 시 해당 페이지가 디스크에 **스왑 아웃**된 상태:

1. 하드웨어가 **페이지 폴트** 발생
    
2. 커널의 페이지 폴트 핸들러 실행
    
3. 디스크에서 해당 페이지를 메모리로 가져오기
    
4. 제어권을 **원래의 `movl` 명령어**(`I_current`)로 복귀
    
5. `movl` 명령어가 문제없이 실행되어 프로그램 계속 진행
    

## ⚠ 폴트 예시 2 (잘못된 메모리 참조 - 복구 불가능)

접근 권한이 없는 유효하지 않은 메모리 주소 접근:

1. **페이지 폴트** 발생
    
2. 커널 핸들러가 주소 유효성 검사 → **유효하지 않음** 감지
    
3. 복구 불가능한 오류로 판단
    
4. 해당 프로세스에게 **SIGSEGV 신호** 전송
    
5. 프로그램이 "Segmentation fault" 오류로 **강제 종료**(Abort)
    

---

<div style="page-break-after: always;"></div>

# 추상화: 프로세스(Process)의 이해

## 들어가며: 가장 심오한 아이디어

### 🤯 컴퓨터 과학에서 가장 심오하고 강력한 아이디어

**프로세스(Process)**

- 단순히 '실행 중인 프로그램' ❌
    
- 운영 체제가 시스템의 모든 작업을 **관리하고 격리**하는 기본 단위 ✅
    
- 각 프로세스를 **독립된 공간**에서 실행 보장
    
- 현대 컴퓨팅의 핵심인 **동시성(concurrency)** 을 안전하게 구현
    

### 🔑 핵심 추상화

프로세스를 통해 **안전한 멀티태스킹** 환경을 제공!

---

<div style="page-break-after: always;"></div>

## 프로세스의 정의와 핵심 추상화

### 📋 프로세스의 정의

**프로세스(Process)** = 실행 중인 프로그램의 **인스턴스(instance)**

### 🔍 명확한 구분

- **프로그램**: 소스 코드가 담긴 파일
    
- **프로세서**: 명령어를 실행하는 하드웨어
    
- **프로세스**: 실행 중인 프로그램의 인스턴스
    

## 🎭 운영 체제가 제공하는 두 가지 중요한 추상화

### 1️⃣ 논리적 제어 흐름 (Logical Control Flow)

- 각 프로그램이 **CPU를 독점적으로 사용**하는 것처럼 보이는 환상
    
- 실제로는 OS가 여러 프로세스 사이를 **매우 빠르게 전환**
    
- 각 프로세스는 자신의 명령어들이 **중단 없이 순차적으로 실행**되는 것처럼 느낌
    
- 구현: **문맥 교환(Context Switching)**
    

### 2️⃣ 사적인 주소 공간 (Private Address Space)

- 각 프로그램이 **메인 메모리 전체를 독점적으로 사용**하는 것처럼 보이는 환상
    
- 모든 프로세스는 **자신만의 독립적인 메모리 공간**
    
- 다른 프로세스의 데이터를 침범할 걱정 없이 **안전하게 작업**
    
- 구현: **가상 메모리(Virtual Memory)**
    

---

<div style="page-break-after: always;"></div>

## 멀티프로세싱: 환상과 현실

### 💻 일상적인 경험

웹 브라우저 + 음악 플레이어 + 문서 편집기를 **동시에** 사용  
→ 멀티프로세싱의 '환상'

## 🔧 시스템 구조에 따른 구현 방식

### 단일 코어의 현실 (동시성, Concurrency)

- 실제로는 **동시 처리 불가능**
    
- CPU가 여러 프로세스 실행을 **아주 짧은 시간 단위로 쪼개서** 번갈아 처리
    
- **문맥 교환(Context Switching)**: 실행되지 않는 프로세스의 상태 정보를 메모리에 저장 → 다시 실행될 때 복원

각 프로세스는 개별적으로 범용 레지스터에 들어있는 값도 있을거고, 스택 따로 있을거고, 힙 따로 있을거고

```
시간: [A][B][A][C][B][A][C]...
     프로세스들이 번갈아가며 실행
```

### 멀티 코어의 현실 (병렬성, Parallelism)

- 여러 개의 CPU 코어가 **물리적으로 존재**
    
- 각 코어가 서로 다른 프로세스를 맡아 **진정으로 동시에 실행**
    

```
코어1: [A][A][A][A]...
코어2: [B][B][B][B]...
코어3: [C][C][C][C]...
      실제로 동시 실행
```

### 📊 동시성 vs 순차성

- **동시적(Concurrent)**: 두 프로세스의 실행 시간이 시간 축 상에서 **겹침**
    
- **순차적(Sequential)**: 하나의 실행이 **완전히 끝난 후** 다른 하나가 시작
    

---

<div style="page-break-after: always;"></div>

## 문맥 교환 (Context Switching)

### 🔄 프로세스 A → 프로세스 B

**문맥 교환(Context Switching)**: CPU 제어권이 넘어가는 구체적인 과정

### 🧠 중요한 관리자: 커널(Kernel)

운영 체제의 핵심 부분으로 문맥 교환을 관리

### ⚠ 반드시 기억할 중요한 점!

**커널은 별개의 독립적인 프로세스가 아니다**


각 프로세스마다

A프로세스 (모드비트 하나 존재, 모드비트에따라 사용자 모드, 커널모드 바뀜)

B프로세스 (모드비트 하나 존재, 모드비트에따라 사용자 모드, 커널모드 바뀜)

a -> 커널 -> b   xxx
a(유저모드) -> a(커널모드) -> b(커널모드) -> b(유저모드)
### 🔍 커널의 실행 방식

- 시스템 관리가 필요할 때마다 **현재 실행 중인 프로세스의 문맥(context) 안에서** 실행
    
- **그 프로세스의 일부로서** 실행
    

### 📝 예시

프로세스 A 실행 중 타이머 인터럽트 발생:

1. CPU가 **사용자 모드** → **커널 모드**로 전환
    
2. **프로세스 A의 일부로서** 커널 코드 실행
    
3. 문맥 교환 수행
    

---

<div style="page-break-after: always;"></div>

# Chapter 5 실전 프로그래밍: 프로세스 제어

## 프로세스 상태와 ID 확인

## 📊 프로그래머 관점에서의 프로세스 상태

## 🟢 실행 (Running)

- 프로세스가 **CPU에서 실행 중**이거나
    
- 실행되기를 기다리며 **스케줄링 큐에 있는** 상태
    

## 🟡 정지 (Stopped)

- 프로세스의 실행이 **일시 중단**된 상태
    
- **특정 신호(Signal)**를 받기 전까지는 스케줄링되지 않음
    

## 🔴 종료 (Terminated)

- 프로세스가 **영구적으로 실행을 멈춘** 상태
    

## 🔍 프로세스 ID 확인 함수

```c
pid_t getpid(void);   // 현재 프로세스의 ID(PID) 반환
pid_t getppid(void);  // 부모 프로세스의 ID(PPID) 반환
```

---

<div style="page-break-after: always;"></div>

## 프로세스 생성: fork()의 마법

## 🎭 fork()의 독특한 특징

**"한 번 호출되지만 두 번 반환된다"**

## 🔧 fork() 함수

현재 실행 중인 **부모 프로세스**가 새로운 **자식 프로세스**를 생성하는 시스템 콜

## 📋 상속받는 것들

- 부모의 **가상 주소 공간**에 대한 동일하지만 **분리된 복사본**
    
- 부모가 열어 둔 **파일 디스크립터**의 동일한 복사본
    

## 🔄 반환 값의 마법
```c
pid_t pid = fork();

if (pid == 0) {
    // 자식 프로세스: 0을 반환받음
} else if (pid > 0) {
    // 부모 프로세스: 자식의 PID(양수)를 반환받음
} else {
    // 오류 발생: -1 반환
}
```
---

<div style="page-break-after: always;"></div>

## 💡 fork.c 예제

```c
// fork.c 예제
int main() {
    pid_t pid;
    int x = 1;

    pid = fork();
    if (pid == 0) {  /* Child */
        printf("child : x=%d\n", ++x); // x는 2가 됨
        exit(0);
    }

    /* Parent */
    printf("parent: x=%d\n", --x); // x는 0이 됨
    exit(0);
}
```
**가능한 출력:**

```
parent: x=0
child : x=2
```
## 🔍 핵심 개념 분석

## 1️⃣ 독립적인 주소 공간

- fork() 호출 시점에 부모의 변수 `x` 값(1)이 자식에게 **복사**
    
- 그 이후 각자의 연산은 **서로에게 전혀 영향 주지 않음**
    
- **별도의 메모리 공간**을 갖기 때문
    

## 2️⃣ 공유 파일 디스크립터

- 부모와 자식 모두 **stdout(표준 출력) 공유**
    
- 두 프로세스의 printf 결과가 **같은 터미널 화면**에 출력
    

## 3️⃣ 실행 순서의 비결정성

- 부모와 자식 중 **어느 프로세스가 먼저 실행될지 예측 불가**
    
- OS 스케줄러에 따라 달라짐
    

---

<div style="page-break-after: always;"></div>

## 프로세스 그래프와 실행 순서

## 📊 프로세스 그래프 (Process Graph)

동시성 프로그램의 **실행 순서(부분 순서, partial ordering)** 를 시각화하는 도구

## 🔍 fork.c 분석

- `fork()` 호출은 반드시 부모와 자식의 `printf`보다 **먼저** 일어나야 함
    
- 두 `printf` 간의 순서는 **정해져 있지 않음**
    

## ✅ 가능한 실행 순서 (topological sort)

- `fork → parent printf → child printf` ✅
    
- `fork → child printf → parent printf` ✅
    

## ❌ 불가능한 실행 순서

- `parent printf → fork` ❌
    

---

<div style="page-break-after: always;"></div>

## 다양한 fork() 패턴 분석

## 1️⃣ 연속된 fork (fork2)
```c
void fork2() {
    printf("L0\n");
    fork();
    printf("L1\n"); 
    fork();
    printf("Bye\n");
}
```

**가능한 출력:** `L0 L1 Bye Bye L1 Bye Bye`  
**불가능한 출력:** `L0 Bye L1 Bye L1 Bye Bye`  
_(L0 다음에 L1이 오지 않고 Bye가 올 수 없음)_

## 2️⃣ 부모에서의 중첩된 fork (fork4)
```c
void fork4() {
    printf("L0\n");
    if (fork() != 0) {        // 부모만 진입
        printf("L1\n");
        if (fork() != 0) {    // 부모만 진입
            printf("L2\n");
        }
    }
    printf("Bye\n");         // 모든 프로세스 실행
}
```
**가능한 출력:** `L0 L1 Bye Bye L2 Bye`  
**불가능한 출력:** `L0 Bye L1 Bye Bye L2`  
_(L0를 출력한 부모 프로세스는 L1 또는 Bye를 출력해야 함)_

---

<div style="page-break-after: always;"></div>

## 3️⃣ 자식에서의 중첩된 fork (fork5)

```c
void fork5() {
    printf("L0\n");
    if (fork() == 0) {        // 자식만 진입
        printf("L1\n");
        if (fork() == 0) {    // 자식의 자식만 진입
            printf("L2\n");
        }
    }
    printf("Bye\n");         // 모든 프로세스 실행
}
```
**가능한 출력:** `L0 Bye L1 L2 Bye Bye`  
**불가능한 출력:** `L0 Bye L1 Bye Bye L2`  
_(L1을 출력한 프로세스는 L2 또는 Bye를 출력해야 함)_

---

<div style="page-break-after: always;"></div>

# Chapter 6 프로세스 종료와 수확: exit, wait, waitpid

## 프로세스 종료 조건

## 🛑 프로세스가 종료되는 3가지 경우

1. **신호 수신**: 종료를 유발하는 기본 동작을 가진 신호 수신
    
2. **main 반환**: main 루틴에서 return
    
3. **exit() 호출**: `exit(status)` 함수를 명시적으로 호출
    

## 📤 exit() 함수

```c
void exit(int status);
```

- 프로세스를 종료시키면서 **정수 값 status**를 OS에 전달
    
- **관례**: status가 0이면 정상 종료, 0이 아니면 오류
    

---

<div style="page-break-after: always;"></div>

## "좀비" 프로세스와 "수확"

## 🧟‍♂️ 좀비(Zombie) 프로세스

- 프로세스가 종료되어도 **종료 상태 정보**가 커널 테이블에 남아있음
    
- **실행되지는 않지만** 시스템 자원을 일부 점유 (아주 약간의 메모리, pid)
    

## 🎣 수확(Reaping)

좀비 프로세스를 **완전히 정리**하는 행위

- **부모 프로세스의 책임!**
    
- `wait()` 또는 `waitpid()` 시스템 콜 호출
    
- 종료된 자식의 상태 정보를 받으면 커널이 좀비 프로세스를 **완전히 제거**
    

## 👨‍👦 고아(Orphaned) 프로세스

부모가 자식을 수확하지 않고 먼저 종료되면?  
→ **init 프로세스(PID 1)** 에 의해 자동으로 입양되고 수확됨  
→ 시스템에 좀비가 **무한정 남지는 않음**

---

<div style="page-break-after: always;"></div>

## wait와 waitpid 함수

## 🕐 wait() 함수
```c
int wait(int *status);
```


- 자신의 **자식 프로세스 중 아무거나 하나**가 종료될 때까지 부모 프로세스 실행 일시 중단
    
- **종료된 자식의 PID** 반환
    
- `status` 포인터를 통해 **종료 상태** 전달
    
- `WIFEXITED`, `WEXITSTATUS` 매크로로 해석 가능
    

## 🎯 waitpid() 함수
```c
pid_t waitpid(pid_t pid, int *status, int options);
```

- `pid` 인자로 **특정한 자식 프로세스**가 종료될 때까지 기다림
    
- **더 유연한 제어** 가능
    

## 📝 예시들

- **fork7**: `wait`를 사용하지 않아 좀비 발생
    
- **fork9**: `wait`를 통해 자식의 종료를 기다리는 동기화
    
- **fork10**: 여러 자식을 순서 없이 수확
    
- **fork11**: `waitpid`를 사용해 특정 순서로 자식 수확
    

---

<div style="page-break-after: always;"></div>

# Chapter 7 새로운 프로그램 실행: execve

## execve 함수의 역할

## 🔄 fork vs execve

- **fork()**: 현재 프로세스를 **복제**
    
- **execve()**: 완전히 새로운 프로그램을 현재 프로세스 위로 **덮어씌움**
    

## 📋 execve() 함수
```c
int execve(char *filename, char *argv[], char *envp[]);
```

- `filename`에 지정된 실행 파일을 로드
    
- 현재 프로세스의 **메모리 공간**(코드, 데이터, 스택)을 새로운 프로그램의 것으로 **완전히 교체**
    

## ⚠ 중요한 특징들

1. **메모리 내용은 바뀜** → **PID, 열린 파일 디스크립터, 신호 컨텍스트는 유지**
    
2. **성공하면 절대 반환하지 않음** → 새로운 프로그램이 시작되기 때문
    

---

<div style="page-break-after: always;"></div>

## 셸(Shell)의 전형적인 패턴

## 🐚 fork() + execve() 조합
```c
// 셸의 명령 실행 패턴
if (fork() == 0) {
    // 자식 프로세스
    execve("/bin/ls", argv, envp);  // ls 명령 실행
    // 이 줄은 절대 실행되지 않음
} else {
    // 부모 프로세스 (셸)
    waitpid(-1, &status, 0);  // 자식이 끝나기를 기다림
    // 다음 명령을 받을 준비
}
```
## 📋 실행 과정

1. **셸**이 `fork()`를 호출하여 **자식 프로세스** 생성
    
2. **자식 프로세스**는 `execve()`를 호출하여 사용자가 입력한 명령어(예: `/bin/ls`) 실행
    
3. **부모 프로세스(셸)**는:
    
    - **포그라운드**: `waitpid()`로 자식 프로세스가 끝나기를 기다림
        
    - **백그라운드**: 기다리지 않고 즉시 다음 명령 받을 준비
        

---

<div style="page-break-after: always;"></div>

# Chapter 8 필수 습관: 시스템 콜 오류 처리

## 오류 처리의 중요성

## ⚠ 시스템 프로그래머의 철칙

**"모든 시스템 레벨 함수의 반환 값은 반드시 확인해야 한다"**

## 🔍 리눅스 시스템 함수의 오류 처리

- 오류 발생 시 일반적으로 **-1 반환**
    
- 전역 변수 `errno`에 **오류 원인 코드** 설정
    

## 📝 표준적인 오류 처리 패턴
```c
// 나쁜 예 ❌
pid = fork();
if (pid == 0) {
    // 자식 프로세스 코드
}

// 좋은 예 ✅  
if ((pid = fork()) < 0) {
    fprintf(stderr, "fork error: %s\n", strerror(errno));
    exit(1);
}
if (pid == 0) {
    // 자식 프로세스 코드
}
```
---

<div style="page-break-after: always;"></div>

## 오류 처리 개선 방법

## 🛠 편의 함수들

## 1️⃣ 오류 보고 함수
```c
void unix_error(char *msg) {
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(1);
}
```
## 2️⃣ 래퍼(Wrapper) 함수
```c
pid_t Fork(void) {
    pid_t pid;
    pid = fork()
    if (pid < 0) {
        unix_error("Fork error");
    }
    return pid;
}
```
## 💡 사용 예시

```c
// 간결하고 안전한 코드
pid_t pid = Fork();
if (pid == 0) {
    // 자식 프로세스 코드
}
```
## 🔧 strerror() 함수

```c
char *strerror(int errnum);
```

- `errno` 코드에 해당하는 **오류 메시지 문자열** 반환
    
- **디버깅에 매우 유용**
    

---

<div style="page-break-after: always;"></div>

# 결론: 핵심 개념 요약

## 🎯 학습한 세 가지 핵심 개념

## 1️⃣ 예외 (Exceptions)

- 하드웨어 인터럽트, 의도적인 트랩, 복구 가능한 폴트 등
    
- 시스템의 **비표준적인 흐름을 제어**하는 기본 메커니즘
    
- 운영 체제가 시스템의 **통제권을 얻고** 다양한 이벤트에 대응하는 **출발점**
    

## 2️⃣ 프로세스 (Processes)

- CPU와 메모리에 대한 **강력한 추상화** 제공
    
- 여러 프로그램이 서로를 침범하지 않고 **안전하고 독립적으로 실행**
    
- 운영 체제의 **기본 단위**
    

## 3️⃣ 프로세스 제어

- `fork`, `exit`, `wait`, `execve`와 같은 **시스템 콜** 사용
    
- 프로그래머가 직접 프로세스의 **생성부터 소멸까지의 생명주기** 관리
    
- **새로운 프로그램 실행** 방법
    

---

<div style="page-break-after: always;"></div>

## 🔗 세 개념의 연결고리

## 📊 상호 관계

- **예외**: 운영체제 커널이 제어권을 획득하는 **유일한 통로**
    
- **커널**: 이 통로를 통해 **문맥 교환**을 수행하여 **멀티프로세싱** 구현
    
- **프로세스 제어**: `fork`, `execve`와 같은 함수들은 **예외의 일종인 시스템 콜**을 통해 모든 강력한 기능을 사용자 프로그램에 제공